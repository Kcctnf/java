package xiaodong;

/**
 * Author : dong
 * Time:2019/7/25
 */
/**
 * 进程：操作系统中的一个程序的执行周期
 * 创建---->就绪-----.>运行------>结束
 * 线程：
 * 区别：没有进程就没有线程，进程一旦终止，其内的线程也将不复存在。多进程与多线程区别：本质区别在于，每个进程拥有自己的一整套变量，而线程则共享数据。共享变量使得线程之间的通信比进程之间通信更有效、更方便。
 * 1.java中的多线程实现方式：
 *     1)
 *     2)
 *     3)
 * 2.多线程常用的操作方法：
 *    a.sleep()：线程休眠：运行态--->阻塞态，不会释放锁，立即交出CPU
 *    b.yield()： 线程让步，运行态---->就绪态，不会释放对象锁，交出CPU时间不确定，由系统调度
 *       只会让拥有相同时间优先级的线程有获取CPU的机会。
 *    c.join()：   当前线程等待另一线程执行完毕后再恢复执行，运行态--->阻塞态，会释放对象锁
 *
 *    d.多线程的等待与唤醒机制
 *        wait()/notify():与synchronized关键字配合使用
 *        要使用wait()/notify()，必须在同步方法或同步代码快中使用
 *    e.wait()：运行态----->阻塞态
 *    f.notify()：阻塞态---->就绪态
 *    g.线程：
 *        java中的线程只有两类：用户线程和守护线程
 *       创建的线程默认都是用户线程，包括主线程
 *       守护线程：后台线程，只有当当前的JVM进程中最后一个用户线程终止，守护线程会对着JVM一同停止（GC线程就是典型的守护线程）
 *        GCDeamn将用户线程置为守护线程，将他置为true
 *
 *
 *
 * Object及其子类的每个对象都有两个队列
 * 同步队列：获取对象锁失败的线程进入同步队列，假如只有一个线程获取锁成功，则其他的进入同步队列。
 * 等待队列：已经获取到锁，调用wait()进入阻塞状态的线程进入等待队列（等待notify()）；等待队列中的线程被notify()（唤醒此队列）之后又会进入同步队
 *
 *
 * 3.同步(保护对象是谁？锁是谁？)
 * jvm  ：内存模型(JMM)：并发程序
 *   描述（类成员变量，静态变量）如何存储
 *
 * 工作内存：变量在线程中的操作（读写）必须在工作内存中进行
 *                   工作内存中保存了所有变量的副本
 *
 * 主内存：所有变量必须在主内存中存储
 *
 * 原子性：一组操作要么同时发生，要么一个都不发生
 * 保证原子性：
 *       a.基本数据类型的读写操作都属于原子性操作。（int i = 20  ；i = 10；i++不是原子性操作）
 *       b.
 * 可见性：某一线程对于变量的修改对于其他线程而言是立即可见的
 * 保证可见性的关键字（Synchronized(Lock)..final..volatile）普通线程不具备可见性
 *
 * 有序性：在单线程场景下，所有代码执行顺序就是我们代码的书写顺序，在多线程场景下，所有代码都是乱序的。
 * 线程安全指的是以上三个特性同时满足
 *
 * 如何解决同步？
 * 1.使用Synchronized关键字解决同步问题
 *     a.同步代码快
 *       synchronized(对象----任意类对象或者类.class对象(反射对象只有一个)) == synchronized(对象)
 *     b.同步方法
 *       synchronized修饰成员方法  锁的是当前对象this
 *                             修饰类方法(static)  锁的是当前类的反射对象（类.class）
 *      当一个锁锁一个对象时，读读互斥
 *      当多个锁锁多个对象时，是异步的
 *
 */