1.哈希桶的代码实现

   给定数据，得到下标   O（1）
   根据下标存到数组中   O（1）


   数组的容量永远小于存放的数据，不同的数据会得到相同的下标，叫做哈希冲突
       1.当保存的个数 / 容量 > 阈值
           进行扩容
       2.恶意制造数据，当哈希的某一个链表过长，就进行树化，再哈希（超过8时）

   1.尽可能减少冲突的发生
   2.如果真的冲突，怎么办
       线性探测
       用链表穿起来

2.AVL代码实现（不记录负载因子，而是记录高度）
   红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。


3.红黑树

   性质1. 节点是红色或黑色。
   性质2. 根节点是黑色。
   性质3 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
   性质4. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

  最短的：黑黑黑黑
  最长的：黑红黑红黑。。。
  最长的长度不能超过最短的两倍

  插入的节点一定是红色的
    1.父亲：黑色   不破坏红黑树的性质，直接返回
    2.父亲：红色   破坏了红色不能与红色相邻，要调整
    3.祖父是黑色的，否则 父亲 - 祖父  红红相邻


 （一）搜索解决的问题
     1.给定key,返回value    （给定key，返回key出现的次数）
     2.判断存在与否